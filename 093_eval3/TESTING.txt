Step(1) Run ./ffosh, and you can see "ffosh$",
   a) you can input command like "/bin/ls", and you can see all the files under this folder and a message "Program was successful" this is correct, because it is full path to the command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ /bin/ls
Extra-Credit.txt  TESTING.txt	    ffosh.cpp	intest	      myec.txt	      shell_cmd.hpp   story2
Makefile	  commandShell.txt  gcc_output	my_shell.cpp  shell_cmd.cpp   shell_cmd.hpp~  wc_output
README		  ffosh		    input.txt	my_shell.hpp  shell_cmd.cpp~  story1
Program was successful

   b) you can input command like "ls", and you can see "Program failed with code 1", this is correct, because it is not a full path to the command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ /bin/ls
Extra-Credit.txt  TESTING.txt	    ffosh.cpp	intest	      myec.txt	      shell_cmd.hpp   story2
Makefile	  commandShell.txt  gcc_output	my_shell.cpp  shell_cmd.cpp   shell_cmd.hpp~  wc_output
README		  ffosh		    input.txt	my_shell.hpp  shell_cmd.cpp~  story1
Program was successful

   c) you can input command like "exit()", and you can see "break now!!!!", this is correct, because it exit successful.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ exit()
break now!!!!

   d) you can just write "./ffosh < input.txt" and you can see the same answers like a) and b).

Example:
./ffosh < input.txt 
ffosh:/home/dw299/ece551/093_eval3 $ '#TESTING.txt#'     README	       ffosh	    input.txt	   my_shell.hpp    shell_cmd.cpp~   story1
 Extra-Credit.txt   TESTING.txt        ffosh.cpp    intest	   myec.txt	   shell_cmd.hpp    story2
 Makefile	    commandShell.txt   gcc_output   my_shell.cpp   shell_cmd.cpp   shell_cmd.hpp~   wc_output
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ '#TESTING.txt#'     README	       ffosh	    input.txt	   my_shell.hpp    shell_cmd.cpp~   story1
 Extra-Credit.txt   TESTING.txt        ffosh.cpp    intest	   myec.txt	   shell_cmd.hpp    story2
 Makefile	    commandShell.txt   gcc_output   my_shell.cpp   shell_cmd.cpp   shell_cmd.hpp~   wc_output
Program was successful

   d) you can just push enter key, you can see it just change a line.

Example:
./ffosh
./ffosh

Step(2) Run ./ffosh, and you can see "ffosh$",
   a)you can input command like "ls", and you can see all the files under this folder and message "Program was successful", this is correst, because it will iterate all the environment path and search this command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls
'#TESTING.txt#'     README	       ffosh	    input.txt	   my_shell.hpp    shell_cmd.cpp~   story1
 Extra-Credit.txt   TESTING.txt        ffosh.cpp    intest	   myec.txt	   shell_cmd.hpp    story2
 Makefile	    commandShell.txt   gcc_output   my_shell.cpp   shell_cmd.cpp   shell_cmd.hpp~   wc_output
Program was successful


   b)you can in put like "ls    -l", and you can see all  the same things like you input "ls -l", this is correct because the program will pass the useless space.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls   -l
total 684
-rw-rw-r-- 1 dw299 dw299   4259 Nov 23 17:48 '#TESTING.txt#'
-rw-r--r-- 1 dw299 dw299   2075 Nov  8 13:59  Extra-Credit.txt
-rw-rw-r-- 1 dw299 dw299    183 Nov 20 20:05  Makefile
-rw-rw-r-- 1 dw299 dw299  18195 Nov  8 13:59  README
-rw-rw-r-- 1 dw299 dw299   3412 Nov 23 17:45  TESTING.txt
-rw-r--r-- 1 root  root    7907 Nov  9 16:17  commandShell.txt
-rwxrwxr-x 1 dw299 dw299 590256 Nov 22 11:24  ffosh
-rw-rw-r-- 1 dw299 dw299   1506 Nov 22 11:24  ffosh.cpp
-rw-rw-r-- 1 dw299 dw299     57 Nov 23 09:03  gcc_output
-rw-rw-r-- 1 dw299 dw299     11 Nov 12 17:43  input.txt
-rw-rw-r-- 1 dw299 dw299      3 Nov 22 15:19  intest
-rw-rw-r-- 1 dw299 dw299  10522 Nov 22 10:52  my_shell.cpp
-rw-rw-r-- 1 dw299 dw299    717 Nov 21 13:39  my_shell.hpp
-rw-rw-r-- 1 dw299 dw299     98 Nov 18 10:12  myec.txt
-rw-rw-r-- 1 dw299 dw299   3224 Nov 21 13:37  shell_cmd.cpp
-rw-rw-r-- 1 dw299 dw299   1749 Nov 20 23:03  shell_cmd.cpp~
-rw-rw-r-- 1 dw299 dw299    446 Nov 21 11:11  shell_cmd.hpp
-rw-rw-r-- 1 dw299 dw299    218 Nov 20 20:17  shell_cmd.hpp~
drwxrwxr-x 2 dw299 dw299    249 Nov  8 13:59  story1
drwxrwxr-x 2 dw299 dw299    213 Nov  8 13:59  story2
-rw-rw-r-- 1 dw299 dw299      4 Nov 23 09:08  wc_output
Program was successful

   c)you can input like ""ls" -l", and you will see the same input when you type ls and pwd. This is correct because the program can recognize the quotation marks, and see these as 2 sepreate command. And when there is a unclosed quotation mark, the program will output error message.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ "ls" -l 
total 688
-rw-rw-r-- 1 dw299 dw299   5187 Nov 23 17:52 '#TESTING.txt#'
-rw-r--r-- 1 dw299 dw299   2075 Nov  8 13:59  Extra-Credit.txt
-rw-rw-r-- 1 dw299 dw299    183 Nov 20 20:05  Makefile
-rw-rw-r-- 1 dw299 dw299  18195 Nov  8 13:59  README
-rw-rw-r-- 1 dw299 dw299   5175 Nov 23 17:50  TESTING.txt
-rw-r--r-- 1 root  root    7907 Nov  9 16:17  commandShell.txt
-rwxrwxr-x 1 dw299 dw299 590256 Nov 22 11:24  ffosh
-rw-rw-r-- 1 dw299 dw299   1506 Nov 22 11:24  ffosh.cpp
-rw-rw-r-- 1 dw299 dw299     57 Nov 23 09:03  gcc_output
-rw-rw-r-- 1 dw299 dw299     11 Nov 12 17:43  input.txt
-rw-rw-r-- 1 dw299 dw299      3 Nov 22 15:19  intest
-rw-rw-r-- 1 dw299 dw299  10522 Nov 22 10:52  my_shell.cpp
-rw-rw-r-- 1 dw299 dw299    717 Nov 21 13:39  my_shell.hpp
-rw-rw-r-- 1 dw299 dw299     98 Nov 18 10:12  myec.txt
-rw-rw-r-- 1 dw299 dw299   3224 Nov 21 13:37  shell_cmd.cpp
-rw-rw-r-- 1 dw299 dw299   1749 Nov 20 23:03  shell_cmd.cpp~
-rw-rw-r-- 1 dw299 dw299    446 Nov 21 11:11  shell_cmd.hpp
-rw-rw-r-- 1 dw299 dw299    218 Nov 20 20:17  shell_cmd.hpp~
drwxrwxr-x 2 dw299 dw299    249 Nov  8 13:59  story1
drwxrwxr-x 2 dw299 dw299    213 Nov  8 13:59  story2
-rw-rw-r-- 1 dw299 dw299      4 Nov 23 09:08  wc_output
Program was successful

   d)you can input like" ls "-l" -a " (the first argument -l is quotated) and you would see the output like you input command "ls -l -a". This is correct, because the program can parse the quotation mark and sepreate "-l" and "-a" as two different argument.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls "-l" -a  
total 704
drwxrwxr-x   5 dw299 dw299   4096 Nov 23 18:31 .
drwxr-xr-x 116 dw299 dw299   4096 Nov 22 13:37 ..
drwxrwxr-x   4 dw299 dw299     72 Nov  8 11:38 .honor
-rw-r--r--   1 dw299 dw299   2075 Nov  8 13:59 Extra-Credit.txt
-rw-rw-r--   1 dw299 dw299    183 Nov 20 20:05 Makefile
-rw-rw-r--   1 dw299 dw299  18195 Nov  8 13:59 README
-rw-rw-r--   1 dw299 dw299  18676 Nov 23 18:31 TESTING.txt
-rw-r--r--   1 root  root    7907 Nov  9 16:17 commandShell.txt
-rwxrwxr-x   1 dw299 dw299 590256 Nov 23 18:07 ffosh
-rw-rw-r--   1 dw299 dw299   1506 Nov 23 18:06 ffosh.cpp
-rw-rw-r--   1 dw299 dw299     57 Nov 23 09:03 gcc_output
-rw-rw-r--   1 dw299 dw299     11 Nov 12 17:43 input.txt
-rw-rw-r--   1 dw299 dw299      3 Nov 22 15:19 intest
-rw-rw-r--   1 dw299 dw299  10522 Nov 22 10:52 my_shell.cpp
-rw-rw-r--   1 dw299 dw299    717 Nov 21 13:39 my_shell.hpp
-rw-rw-r--   1 dw299 dw299     98 Nov 18 10:12 myec.txt
-rw-rw-r--   1 dw299 dw299   3224 Nov 21 13:37 shell_cmd.cpp
-rw-rw-r--   1 dw299 dw299   1749 Nov 20 23:03 shell_cmd.cpp~
-rw-rw-r--   1 dw299 dw299    446 Nov 21 11:11 shell_cmd.hpp
-rw-rw-r--   1 dw299 dw299    218 Nov 20 20:17 shell_cmd.hpp~
drwxrwxr-x   2 dw299 dw299    249 Nov  8 13:59 story1
drwxrwxr-x   2 dw299 dw299    213 Nov  8 13:59 story2
-rw-rw-r--   1 dw299 dw299      4 Nov 23 09:08 wc_output
Program was successful

   e)if you input like "\"ls"\" or \\a\\b, the program will output the Program failed with code 1, and you can see the real arguments like "ls" or \a\b, this is correct because the program will support escaped quotation marks (\") and backslashes (\\) to allow the user to write a literal quotation mark and backslashes, but it is not a real command for the shell, so it just shows command not found.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ \"ls\"
Command "ls" not found
Program failed with code 1
ffosh:/home/dw299/ece551/093_eval3 $ \\a\\b
Command \a\b not found
Program failed with code 1

   f)if you input like ls- l -12314. The output would be like this. This is true. because '2' is an invalid option.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls -l -12314
ls: invalid option -- '2'
Try 'ls --help' for more information.
Program failed with code 2


Step(3) Run ./ffosh, and you can see "ffosh:$WORK_PATH$" for me it's "ffosh:/home/dw299/ece551/093_eval3 $"
   a)you can input command "ls", and you can see all the files in this directory. And you input like "cd ." and "ls", you can see all the files in this directory. This is correct, because "cd ." would not change the directory.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls
Extra-Credit.txt  TESTING.txt	    ffosh.cpp	intest	      myec.txt	      shell_cmd.hpp   story2
Makefile	  commandShell.txt  gcc_output	my_shell.cpp  shell_cmd.cpp   shell_cmd.hpp~  wc_output
README		  ffosh		    input.txt	my_shell.hpp  shell_cmd.cpp~  story1
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cd .
ffosh:/home/dw299/ece551/093_eval3 $ ls
Extra-Credit.txt  TESTING.txt	    ffosh.cpp	intest	      myec.txt	      shell_cmd.hpp   story2
Makefile	  commandShell.txt  gcc_output	my_shell.cpp  shell_cmd.cpp   shell_cmd.hpp~  wc_output
README		  ffosh		    input.txt	my_shell.hpp  shell_cmd.cpp~  story1
Program was successful

   b)you can input command "ls", and you can see all the files in this directory. And you input like "cd ./story1" and "ls", you can see all the files in story1 directory. This is correct, because "cd ." would not change the directory.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls
Extra-Credit.txt  TESTING.txt	    ffosh.cpp	intest	      myec.txt	      shell_cmd.hpp   story2
Makefile	  commandShell.txt  gcc_output	my_shell.cpp  shell_cmd.cpp   shell_cmd.hpp~  wc_output
README		  ffosh		    input.txt	my_shell.hpp  shell_cmd.cpp~  story1
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cd ./story1
ffosh:/home/dw299/ece551/093_eval3/story1 $ ls
page1.txt   page11.txt	page13.txt  page2.txt  page4.txt  page6.txt  page8.txt
page10.txt  page12.txt	page14.txt  page3.txt  page5.txt  page7.txt  page9.txt
Program was successful

   c)you can input command "env", and you can see environ varibles. This is correct because the program support "env" command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ env
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
SSH_CONNECTION=98.26.60.237 61488 152.3.77.223 22
LESSCLOSE=/usr/bin/lesspipe %s %s
LANG=en_US.UTF-8
EDITOR=emacs -nw
S_COLORS=auto
XDG_SESSION_ID=99885
USER=dw299
PWD=/home/dw299/ece551/093_eval3
HOME=/home/dw299
LC_CTYPE=UTF-8
SSH_CLIENT=98.26.60.237 61488 22
SSH_TTY=/dev/pts/10
MAIL=/var/mail/dw299
VISUAL=emacs -nw
TERM=xterm-256color
SHELL=/bin/bash
SHLVL=1
LOGNAME=dw299
XDG_RUNTIME_DIR=/run/user/1640
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
LESSOPEN=| /usr/bin/lesspipe %s
_=./ffosh
OLDPWD=/home/dw299/ece551

   d)if you first input "set a 123" and then you input "env", you would see environ var same as previous one. Because you haven't export it. after you input "export a" and then input "env" you can see "a=123" in the last. This is correct. Because you set and export var successfully.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ set a 123
ffosh:/home/dw299/ece551/093_eval3 $ env
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
SSH_CONNECTION=98.26.60.237 61488 152.3.77.223 22
LESSCLOSE=/usr/bin/lesspipe %s %s
LANG=en_US.UTF-8
EDITOR=emacs -nw
S_COLORS=auto
XDG_SESSION_ID=99885
USER=dw299
PWD=/home/dw299/ece551/093_eval3
HOME=/home/dw299
LC_CTYPE=UTF-8
SSH_CLIENT=98.26.60.237 61488 22
SSH_TTY=/dev/pts/10
MAIL=/var/mail/dw299
VISUAL=emacs -nw
TERM=xterm-256color
SHELL=/bin/bash
SHLVL=1
LOGNAME=dw299
XDG_RUNTIME_DIR=/run/user/1640
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
LESSOPEN=| /usr/bin/lesspipe %s
_=./ffosh
OLDPWD=/home/dw299/ece551
ffosh:/home/dw299/ece551/093_eval3 $ export a
ffosh:/home/dw299/ece551/093_eval3 $ env
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
SSH_CONNECTION=98.26.60.237 61488 152.3.77.223 22
LESSCLOSE=/usr/bin/lesspipe %s %s
LANG=en_US.UTF-8
EDITOR=emacs -nw
S_COLORS=auto
XDG_SESSION_ID=99885
USER=dw299
PWD=/home/dw299/ece551/093_eval3
HOME=/home/dw299
LC_CTYPE=UTF-8
SSH_CLIENT=98.26.60.237 61488 22
SSH_TTY=/dev/pts/10
MAIL=/var/mail/dw299
VISUAL=emacs -nw
TERM=xterm-256color
SHELL=/bin/bash
SHLVL=1
LOGNAME=dw299
XDG_RUNTIME_DIR=/run/user/1640
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
LESSOPEN=| /usr/bin/lesspipe %s
_=./ffosh
OLDPWD=/home/dw299/ece551
a=123

   e)you can input "set a 123" and the input "rev a" and "export a", finally input "env". You would see "a=321" at last. This is correct. Because you set, reverse and export a varible successfully.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ set a 123
ffosh:/home/dw299/ece551/093_eval3 $ rev a
ffosh:/home/dw299/ece551/093_eval3 $ export a
ffosh:/home/dw299/ece551/093_eval3 $ env
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:
SSH_CONNECTION=98.26.60.237 61488 152.3.77.223 22
LESSCLOSE=/usr/bin/lesspipe %s %s
LANG=en_US.UTF-8
EDITOR=emacs -nw
S_COLORS=auto
XDG_SESSION_ID=99885
USER=dw299
PWD=/home/dw299/ece551/093_eval3
HOME=/home/dw299
LC_CTYPE=UTF-8
SSH_CLIENT=98.26.60.237 61488 22
SSH_TTY=/dev/pts/10
MAIL=/var/mail/dw299
VISUAL=emacs -nw
TERM=xterm-256color
SHELL=/bin/bash
SHLVL=1
LOGNAME=dw299
XDG_RUNTIME_DIR=/run/user/1640
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
LESSOPEN=| /usr/bin/lesspipe %s
_=./ffosh
OLDPWD=/home/dw299/ece551
a=321

   f)also you can access var by using "$".
     1.If you input "the user is $USER" you would see "the user is dw299". This is true, because we can access the var by "$"

Example:
ffosh:/home/dw299/ece551/093_eval3 $ the user is $USER
the user is dw299

     2.If you input "the user is $USER$PWD", you would see "the user is dw299/home/dw299/ece551/093_eval3". This is true, because we can access var by "$", even two var is concate.
      
Example:
ffosh:/home/dw299/ece551/093_eval3 $ the user is $USER$PWD
the user is dw299/home/dw299/ece551/093_eval3
      
     3.If you input like "the user is $USER$", you would see "the user is dw299$". This is true, because the second "$" is the last char in string. We cannot access var by it.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ the user is $USER$
the user is dw299$

     4.If you first "set a ls", which means you set a=ls, then you access a by using "$a", you would see the result as you input "ls" command. This is true, because a=ls and you just input "$a", it equals to you just input "ls" command. So we cannot find it and it's value.
     
Example:
ffosh:/home/dw299/ece551/093_eval3 $ set a ls
ffosh:/home/dw299/ece551/093_eval3 $ $a
'#TESTING.txt#'     README	  commandShell.txt   intest	    myec.txt	    shell_cmd.cpp~   story1
 Extra-Credit.txt   TESTING.txt   ffosh		     my_shell.cpp   page1.txt	    shell_cmd.hpp    story2
 Makefile	    cat		  ffosh.cpp	     my_shell.hpp   shell_cmd.cpp   shell_cmd.hpp~   wc_output
Program was successful

     5.If you first "set a wqe", which means you set a=qwe, then you access a by using "$a", you would see the result like "Command qwe not found". This is true, because a=qwe and you just input "$a", it equals to you just input "qwe" commend. And it is not a valid command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ set a qwe
ffosh:/home/dw299/ece551/093_eval3 $ $a
Command qwe not found
Program failed with code 1

     If you want to see a's value, you can just input like "a is $a", and you can see the output like "a is qwe". This is true, because "a is qwe" is a sentence but not a command.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ set a qwe
ffosh:/home/dw299/ece551/093_eval3 $ a is $a
a is qwe


Step(4): Run ./ffosh, and test the redirection and pipe!
   a)you can input command like "gcc 2> error_out" and then input "cat error_out", and you would see the error message in error_out. This is correct, because we redirect the stderr to the error_out. SO, the error message is in the error_out file.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ gcc 2> error_out
Program failed with code 1
ffosh:/home/dw299/ece551/093_eval3 $ cat error_out
gcc: fatal error: no input files
compilation terminated.
Program was successful

   b)you can input command like "ls > out1" and "cat out1", and you would see result like below. This is correct, because we just redirect the output from stdout to out1, so if we "cat" it, we can see the result.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls > out1 
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cat out1
123
Extra-Credit.txt
Makefile
README
TESTING.txt
cat
commandShell.txt
ffosh
ffosh.cpp
intest
my_shell.cpp
my_shell.hpp
myec.txt
out1
page1.txt
shell_cmd.cpp
shell_cmd.cpp~
shell_cmd.hpp
shell_cmd.hpp~
story1
story2
wc_output
Program was successful
   
   c)you can input command like "cat < myec.txt" and you would see result like below. This is correct, because we just redirect the input from stdin to myec.txt, so if we input like that, we can see the result.
Example:
ffosh:/home/dw299/ece551/093_eval3 $ cat < myec.txt  
Step 1: 83ac453dc620b2bdbb825c525e310f8f0c71140e
Step 2: a18e9ba4a72e717be32cf56200f5bbe14693828e
Step 3: c671e28bf8da84602a9e0338841a60ec1eeb2c7f
Program was successful
    
   d)you can input command like "wc -l < README > out3" and "cat out3", you would see 437 in file out3. This is correct, because we redirect input and out from stdin and stdout to README and out3. So the input argument of "wc -l" is README, and the output result will be save in the file 3.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ wc -l < README > out3     
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cat out3
437
Program was successful

   e)you can input command like "wc -l > out3 < README" and "cat out3", you would see 437 in file out3. This is correct, because we redirect input and out from stdin and stdout to README and out3. So the input argument of "wc -l" is README, and the output result will be save in the file 3.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ wc -l>out3<README
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cat out3
437

   f)And if we input like "wc < FILE_NAME > out3 -l" or "< FILE_NAME > wc_output wc -l" or " wc -l > wc_output < FILE_NAME" or other permutations, we will see the result same as previous(d and e). This is correct, because the program can recognize the redirect input file and output file. Besides, the program can also recognize the space(like example in e), that means the result of "wc -l>out3<README" and "wc -l > out3 < README" is same


   g)We can input "ls | cat" to test the pipe, and you would see the result like below. This is correct, we do "ls" command and the output would pass the cat by pipe. So, we could see the result like this.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ ls | cat
123
234
Extra-Credit.txt
Makefile
README
TESTING.txt
cat
commandShell.txt
ffosh
ffosh.cpp
intest
my_shell.cpp
my_shell.hpp
myec.txt
out1
out2
out3
out4
page1.txt
shell_cmd.cpp
shell_cmd.cpp~
shell_cmd.hpp
shell_cmd.hpp~
story1
story2
Program was successful
Program was successful
    
   h)And we also can mix the redirection and pipe together, eg: we can input "cat README | wc -l > wc_out", and you can use "ls" to see the files in this dictionary, and use "cat" to see the content. This is correct, because the output of "cat README" pass to the "wc" command by the pipe. And in the "wc" command, we realized redirection. So we can see the output like this.

Example:
ffosh:/home/dw299/ece551/093_eval3 $ cat README | wc -l > wc_out
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ ls
123		  Makefile     cat		 ffosh.cpp     my_shell.hpp  out2  page1.txt	   shell_cmd.hpp   story2
234		  README       commandShell.txt  intest        myec.txt      out3  shell_cmd.cpp   shell_cmd.hpp~  wc_out
Extra-Credit.txt  TESTING.txt  ffosh		 my_shell.cpp  out1	     out4  shell_cmd.cpp~  story1
Program was successful
ffosh:/home/dw299/ece551/093_eval3 $ cat wc_out
438
Program was successful
